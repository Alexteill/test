/**
 * Runtime module loader type
 */
declare enum ModuleLoader {
    FEDERATION = "FEDERATION"
}
/**
 * Officially supported frameworks
 */
declare enum Framework {
    React = "React"
}
/**
 * Rendering environment
 */
declare enum Environment {
    Client = "Client",
    Server = "Server"
}
/**
 * Webflow props types
 */
declare enum PropType {
    Id = "Id",
    Text = "Text",
    RichText = "RichText",
    Link = "Link",
    Image = "Image",
    Visibility = "Visibility",
    Slot = "Slot"
}

type PropValues<NodeType = unknown> = {
    [PropType.Id]: string;
    [PropType.Text]: string;
    [PropType.RichText]: NodeType;
    [PropType.Link]: {
        href: string;
        target?: "_self" | "_blank" | string;
        preload?: "prerender" | "prefetch" | "none" | string;
    };
    [PropType.Image]: {
        src: string;
        alt?: string;
    };
    [PropType.Visibility]: boolean;
    [PropType.Slot]: NodeType;
};
type PropTypesWithRequiredDefaultValue = never;
type PropTypesWithOptionalDefaultValue = PropType.Text | PropType.Visibility;
type PropTypesWithoutDefaultValue = PropType.Id | PropType.Link | PropType.Image | PropType.Slot | PropType.RichText;
type ComponentProp<T extends PropType = PropType, NodeType = unknown> = T extends PropTypesWithRequiredDefaultValue ? {
    defaultValue: PropValues<NodeType>[T];
    type: T;
    displayName: string;
} : T extends PropTypesWithOptionalDefaultValue ? {
    defaultValue?: PropValues<NodeType>[T];
    type: T;
    displayName: string;
} : T extends PropTypesWithoutDefaultValue ? {
    defaultValue?: undefined;
    type: T;
    displayName: string;
} : never;
type ComponentProps<P extends {}, NodeType> = {
    [K in keyof P as undefined extends P[K] ? never : K]: ComponentProp<PropTypeCompatibleWith<P[K], NodeType>, NodeType>;
} & {
    [K in keyof P as undefined extends P[K] ? K : never]?: ComponentProp<PropTypeCompatibleWith<P[K], NodeType>, NodeType>;
};
type PropTypeCompatibleWith<T, NodeType> = {
    [P in PropType]: T extends PropValues<NodeType>[P] ? P : never;
}[PropType];
type ComponentRuntimeProps<NodeType> = {
    [name: string]: PropValues<NodeType>[PropType];
};
type ComponentRuntimeError = {
    error: Error;
    message: string;
    stack?: string;
    code?: string;
};
type ComponentRuntimeOptions = {
    onError?: (error: ComponentRuntimeError) => void;
};
type ComponentOptions = {
    applyTagSelectors?: boolean;
};
type ComponentData<P extends {}, NodeType> = {
    name: string;
    description?: string;
    group?: string;
    props?: ComponentProps<P, NodeType>;
    options?: ComponentOptions;
};
type ComponentDefinition<ComponentType, NodeType, Props extends {}> = ComponentData<Props, NodeType> & {
    component: ComponentType;
    framework: Framework;
};
type ComponentClientRendererFactory<ComponentType, RootType, NodeType> = (component: ComponentType) => ComponentClientRenderer<RootType, NodeType>;
type ComponentClientRenderer<RootType, NodeType> = {
    mount: (domNode: Element) => RootType;
    hydrate: (domNode: Element, props?: ComponentRuntimeProps<NodeType>, options?: ComponentRuntimeOptions) => RootType;
    render: (root: RootType, props?: ComponentRuntimeProps<NodeType>, options?: ComponentRuntimeOptions) => void;
    createSlot: (name: string) => NodeType;
};
type ComponentServerRendererFactory<ComponentType, StreamType, StreamOptionsType, NodeType> = (component: ComponentType) => ComponentServerRenderer<StreamType, NodeType, StreamOptionsType>;
type ComponentServerRenderer<StreamType, NodeType, StreamOptionsType> = {
    renderToStream: (props?: ComponentRuntimeProps<NodeType>, options?: ComponentRuntimeOptions, streamOptions?: StreamOptionsType) => StreamType;
    createSlot: (name: string) => NodeType;
};
/**
 * Renderer interface implementing required render
 * lifecycle methods for specific a specific framework.
 */
type ComponentRendererInterface<ComponentType, RootType, NodeType, StreamType, StreamOptionsType> = {
    ClientRenderer: ComponentClientRendererFactory<ComponentType, RootType, NodeType>;
    ServerRenderer: ComponentServerRendererFactory<ComponentType, StreamType, StreamOptionsType, NodeType>;
};
/**
 * Webflow runtime renderer module's default export
 */
type ComponentRendererRuntimeModule<ComponentType, RootType, NodeType, StreamType, StreamOptionsType> = {
    env: Environment.Client;
    Renderer: ComponentClientRendererFactory<ComponentType, RootType, NodeType>;
} | {
    env: Environment.Server;
    Renderer: ComponentServerRendererFactory<ComponentType, StreamType, StreamOptionsType, NodeType>;
};

type BaseOptions = {
    name: string;
    group?: string;
};
type PropOptions<T extends PropType> = T extends PropTypesWithRequiredDefaultValue ? {
    defaultValue: PropValues[T];
} & BaseOptions : T extends PropTypesWithOptionalDefaultValue ? {
    defaultValue?: PropValues[T];
} & BaseOptions : T extends PropTypesWithoutDefaultValue ? BaseOptions : never;
type PropConstructor<T extends PropType> = (opts: PropOptions<T>) => ComponentProp<T>;
/**
 * Webflow props definition constructor
 */
declare const props: {
    Id: PropConstructor<PropType.Id>;
    Text: PropConstructor<PropType.Text>;
    RichText: PropConstructor<PropType.RichText>;
    Link: PropConstructor<PropType.Link>;
    Image: PropConstructor<PropType.Image>;
    Visibility: PropConstructor<PropType.Visibility>;
    Slot: PropConstructor<PropType.Slot>;
};

/**
 * Validates that input data is of type ComponentData
 */
declare function parseComponentData<P extends {}, NodeType>(input: unknown): ComponentData<P, NodeType>;

type SSRAnnotations = Record<string, string | number | Array<string | number>>;
type SSRManifest = {
    metadata: {
        annotations: SSRAnnotations;
    };
    spec: {
        identifier: string;
        entrypoint: string;
        type: "esm";
    };
};

export { type ComponentClientRendererFactory, type ComponentData, type ComponentDefinition, type ComponentOptions, type ComponentProps, type ComponentRendererInterface, type ComponentRendererRuntimeModule, type ComponentRuntimeError, type ComponentRuntimeOptions, type ComponentRuntimeProps, type ComponentServerRendererFactory, Environment, Framework, ModuleLoader, PropType, type PropValues, type SSRAnnotations, type SSRManifest, parseComponentData, props };
